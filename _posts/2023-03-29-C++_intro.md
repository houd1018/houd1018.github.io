---
title: C++_intro
date: 2023-03-29 20:00:00 -800
categories: [C plus plus]
tags: [c plus plus, programming language]    # TAG names should always be lowercase
---

## intro
### Constants

```c++
const int myNum = 15;  // myNum will always be 15
myNum = 10;  // error: assignment of read-only variable 'myNum'
```

### C++ User Input

```c++
int x; 
cout << "Type a number: "; // Type a number and press enter
cin >> x; // Get user input from the keyboard
cout << "Your number is: " << x; // Display the input value
```

### String

#### Append

A string in C++ is actually an object, which contain functions that can perform certain operations on strings. For example, you can also concatenate strings with the `append()` function:

```c++
string firstName = "John ";
string lastName = "Doe";
string fullName = firstName.append(lastName);
cout << fullName;
```

#### Length

You might see some C++ programs that use the `size()` function to get the length of a string. This is just an alias of `length()`. It is completely up to you if you want to use `length()` or `size()`:

```c++
string txt = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
cout << "The length of the txt string is: " << txt.length();
cout << "The length of the txt string is: " << txt.size();
```

#### access

You can access the characters in a string by referring to its index number inside square brackets `[]`.

```c++
string myString = "Hello";
cout << myString[0];
// Outputs H
```

#### stringstream 

- *Operator >>* Extracts formatted data.
- *Operator <<* Inserts formatted data.
- *Method str()* Gets the contents of underlying string device object.
- *Method str(string)* Sets the contents of underlying string device object.

```c++
stringstream ss(line);
getline(ss, extract, ',')
```

```c++
stringstream ss("23,4,56");
char ch;
int a, b, c;
ss >> a >> ch >> b >> ch >> c;  // a = 23, b = 4, c = 56
// Here  is a storage area for the discarded commas.
```

```c++
string to_string() {
    stringstream ss;
    ss << age << "," << first_name << "," << last_name << "," << standard;
```

### Header

````c++
// Include the cmath library
#include <cmath>

cout << sqrt(64);
cout << round(2.6);
cout << log(2);
````

### Booleans

Outputs 1 (true)

Outputs 0 (false)

````c++
bool isCodingFun = true;
bool isFishTasty = false;
cout << isCodingFun;  // Outputs 1 (true)
cout << isFishTasty;  // Outputs 0 (false)
````

### Short Hand If Else

````c++
int time = 20;
string result = (time < 18) ? "Good day." : "Good evening.";
cout << result;
````

### Pointer

assigns the memory address of *val* to pointer *p*. 

```c++
int* p = & val
```

To access the content of the memory pointed to, prepend the variable name with a `*`.

```c++
*p
```

**Reference Operator**

When used in a variable declaration, the `&` symbol indicates that the variable is a reference to another variable.

```c++
int x = 10;
int &ref = x; // ref is a reference to x
```

## Class

It's a common practice to make all variables private, and set/get them using public methods. For example:

```c++
class SampleClass {
    private:
        int val;
    public:
        void set(int a) {
            val = a;
        }
        int get() {
            return val;
        }
};
```

### Overload operator

- In C++, a `friend` function is a function that is not a member of a class but is granted access to the class's private and protected members. 

```c++
class Vector {
public:
    int x, y;

    Vector(int x, int y) : x(x), y(y) {}

    // Overloading + operator as a member function
    Vector operator+(const Vector& other) const {
        return Vector(x + other.x, y + other.y);
    }
};
```

```c++
    //Overload operator < as specified
    friend bool operator< (Box const& A, Box const& B){
        if( (A.l < B.l) || ((A.b < B.b) && (A.l == B.l)) || ((A.h < B.h) && (A.l == B.l) && (A.b == B.b)) ){
            return true;
        }else{
            return false;
        }
    }
```

### member variables

The syntax `this->n = n;` assigns the value of the parameter `n` to the class's member variable `n`.

```c++
class BadLengthException{
    private:
        int n;
    public:
        BadLengthException(int n){
            this->n = n;
        }
};
```

### exception handling

-  `std::bad_alloc`, which are typically thrown when dynamic memory allocation fails
- `std::exception` class is a standard C++ exception type, and `error.what()` typically returns a C-string describing the error. This catch block will handle any exception derived from the 
- `catch (...)`: This is a catch-all handler that will catch any exception not caught by the preceding handlers. non-standard exception 

```c++
        try {
            cout << Server::compute(A,B) << endl;
        } 
        catch (bad_alloc& error) {
            cout << "Not enough memory" << endl;
        }
        catch (exception& error) {
            cout << "Exception: " << error.what() << endl;
        }
        catch (...) {
            cout << "Other Exception" << endl;
        }
```

### Inheritance 

```c++
class Animal {   // Base class
public:
    void eat() {
        cout << "Eating..." << endl;
    }
};

class Dog : public Animal {  // Derived class
public:
    void bark() {
        cout << "Barking..." << endl;
    }
};

int main() {
    Dog d;
    d.eat();   // Calling base class function
    d.bark();  // Calling derived class function
    return 0;
}
```

**Public Inheritance (`public`)**:

- When a class is derived with public inheritance, all public members of the base class become public members of the derived class, and all protected members of the base class remain protected in the derived class.

**Protected Inheritance (`protected`)**:

- With protected inheritance, all public and protected members of the base class become protected members of the derived class.

**Private Inheritance (`private`)**:

- In private inheritance, all public and protected members of the base class become private members of the derived class.

### Virtual

```c++
class Person{
    private:
    std::string name;
    int age;
    Person() {}
    virtual void getdata() {}
    virtual void putdata() {}
    virtual ~Person() {}
};
```

`virtual ~Person() {}`: The virtual destructor. It is crucial for a class hierarchy when you're dealing with polymorphism, as it ensures that the destructor of the derived class is called when an object is deleted through a pointer to the base class.

### Virtual Inheritance

Virtual inheritance solves this by ensuring that only one copy of the base class's members is inherited by the most derived class.

```c++
class A {
public:
    int data;
};

class B : virtual public A { /* ... */ };
class C : virtual public A { /* ... */ };

class D : public B, public C { /* ... */ };
```

In this setup, `B` and `C` virtually inherit from `A`. As a result, there is only one copy of `A` in `D`, even though `D` inherits from both `B` and `C`.

## STL

### Vector

- *Declaration:*

  ```c++
  vector<int>v; (creates an empty vector of integers)
  ```

- *Size:*

  ```c++
  int size=v.size();
  ```

- *Pushing an integer into a vector:*

  ```c++
  v.push_back(x);(where x is an integer.The size increases by 1 after this.)
  ```

- *Popping the last element from the vector:*

  ```c++
  v.pop_back(); (After this the size decreases by 1)
  ```

- *Sorting a vector:*

  ```c++
  sort(v.begin(),v.end()); (Will sort all the elements in the vector)
  ```

- *erase(int position):*

  ```
  Removes the element present at position.  
  Ex: v.erase(v.begin()+4); (erases the fifth element of the vector v)
  ```

- *erase(int start,int end):*

  ```
  Removes the elements in the range from start to end inclusive of the start and exclusive of the end.
  Ex:v.erase(v.begin()+2,v.begin()+5);(erases all the elements from the third element to the fifth element.)
  ```
